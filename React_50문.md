### 상태관리를 왜 할까요? 그리고 평소 state 관리는 어떻게 하시나요?

- 단순 정보전달의 정적인 웹 사이트 부터 상호작용으로 구성되는 동적 웹 페이지로 변화하는 과정 속에서 데이터 관리의 필요성이 나타났습니다.
- 한가지 예로 DB로부터 받아온 데이터가 공통적으로 재사용 되는 일이 늘어남에 따라 API 호출 횟수에 직접적으로 연관되는 DB의 의존도를 줄일 필요가 있었습니다.
- 데이터가 필요할 때 마다 서버를 호출 하는 것은 비효율적 이므로 DB로부터 분리된 상태 저장소의 필요성이 나타나게 되었습니다.
- 정확하고 효율적인 상태 관리는 DB와의 접촉 횟수를 줄여주며 안정적이고 지속적인 서비스 제공을 가능하게 합니다.
- 현재 상태관리 라이브러리 중 하나인 Redux-toolkit를 사용하여 전역적으로 상태를 관리해 단방향 데이터 흐름을 지키기위해 노력하고 있습니다.
- 상태관리를 하는 이유는 유저와의 상호작용으로부터 데이터를 갱신시켜줘야 하기 때문으로 알고 있습니다.
- 저는 상태관리를 어떠한 동작에 의해 UI,UX 내의 변화가 필요할 때
    - 그 데이터가 단독으로 관리 가능하다면 useState를 이용해서 지역적으로 관리하고
    - 비동기통신의 결과로 로딩여부가 필요하거나 다른 컴포넌트들에서 그 데이터를 사용한다면 redux를 사용해 전역적으로 관리합니다.

### Redux가 무엇인가요, 왜 Redux를 사용하시나요?

- 리덕스란 전역 상태 저장소입니다.
- 저장된 데이터를 App 이 가져다 쓰고, 자식들도 가져다 쓰는 것입니다.
- 부모의 state를 간섭하는 것이 아니라서 유용하게 쓰입니다.
- 아래로 전달해주기 위해 쓸데없는 데이터를 가지고 있게 되는 props driling을 해결해주기 위해 리덕스를 사용한다.

### Redux 말고 다른 전역 상태관리 아는 것 하나와 차이점을 말해주세요

- Redux는 store라는 관리 공간 속에서 여러 reducer들을 이용해 **각각의 reducer에서 쓰이는 state를 관리하는 방식으로 운영**된다.
- 반면, Recoil은 atom이라는 즉, **원자라고 불리는 상태 저장소를 통해 state를 관리**한다.
- 이 atom은 **store와 같은 하나의 전역 관리 객체 속에서 관리되는 방식이 아닌 말그대로 각각의 atom에 관리되고 있다.**
- Redux의 핵심은 reducer를 통해서 state를 관리하는 것인데 이때 **state를 저장, 변경, 삭제 등을 하기 위해 dispatch라는 메소드를 이용해 관리**한다.
- dispatch를 이용할 때는 두 가지 값이 필요한데, 하나는 **우리가 현재 가지고 있는 state**이며 다른 하나는 이 state를 이용해서 **어떠한 행위와 갱신할 값의 정보를 들고 있는 action이 필요**하다.
- 반면 **Recoil은** dispatch의 방식이 아닌 우리가 React에서 익숙하게 쓰고 있는 **useState의 형식을 그대로 따라간다.**
- useRecoilState를 이용해서 atom에 있는 값들을 변화하여 상태관리를 할 수 있는데 이 Recoil에는 useState에서 쓰이는 기존 값을 불러오는 읽기 전용, 기존 값을 덮어씌우는 쓰기 전용으로도 **함수를 따로 분리해 쓸 수 있도록 했다는 점이 특징**이다.

### 버츄얼 돔과 리얼 돔의 차이를 설명해주세요

- DOM은 웹 브라우저가 html 파일, 문서를 접근하기 위한 혹은 인식하기 위한 모델, 방식, 인터페이스입니다.
- JavaScript는 이러한 웹 페이지들의 태그를 인식해 추가, 수정, 삭제, 변화 등 다양한 작업을 처리할 수 있습니다.
- 기존의 DOM 요소에서 데이터를 저장하거나 변경하는 사항이 생기면 DOM을 전부 갱신하여 새로 불러와줘야 한다는 제약이 있습니다.
- React에서는 이 과정이 반복되는 것이 비효율적이라고 생각하였고, DOM을 본 뜬 가상 DOM을 이용하면 데이터의 변화가 생길 때 가상 DOM과 DOM을 비교해 달라진 부분만을 변경하여 갱신해줌으로서 불필요하게 DOM을 전부 불러오는 문제를 방지할 수 있었습니다.

### useRef에 대해 설명해보세요
- **useRef**란 어떠한 **특정 DOM**을 선택할 수 있게 해줍니다.
- 코딩을 하다보면 DOM을 직접 선택해서 포커스를 주거나 특정 엘리먼트의 크기나 색상을 변경하는 경우가 있는데 그때 사용하는 것입니다.
- 특정 DOM을 선택하는 용도 이외에도 **Component 안에서 조회 및 수정이 가능한 변수를 관리하는 용도**로도 사용된다.
- 하지만 **useRef** 이용해서 변수를 업데이트 하게 되면 해당 Component가 리렌더링 되지 않기 때문에 용도에 맞게 사용해야 합니다.

### useEffect의 실행 순서에 대해 설명해주세요

- 우선 **최초로 사이트를 띄울 시, useEffect의 내용이 반드시 실행**되도록 되어있습니다.
- 이 과정 속에서 dependency array, **의존성 배열**의 존재가 중요하게 됩니다.
    - 의존성 배열 자체가 없다면 **useEffect는 렌더링이 일어날 때마다 계속 실행됩니다**.
    - **의존성 배열이 있고, 내부에 요소가 없다면 useEffect는 최초로 사이트를 띄운 이후부터는 실행되지 않습니다.**
    - **의존성 배열이 있고, 내부에 요소가 있다면 해당 요소의 데이터가 변경되거나 갱신될 때마다 useEffect의 내용이 실행**되도록 되어있습니다.
- useEffect에서는 갱신 시 실행되는 업데이트 내용 외에도, **useEffect를 적용한 컴포넌트가 제거될 시 리소스를 정리해야 합니다.**
이 과정을 React에서는 Clean-up이라고 부르며, **업데이트 내용 뒤에 return을 붙여 cleanup을 적용하도록 합니다.**

### useEffect의 실행 순서에 대해 설명해주세요

- 우선 **최초로 사이트를 띄울 시, useEffect의 내용이 반드시 실행**되도록 되어있습니다.
- 이 과정 속에서 dependency array, **의존성 배열**의 존재가 중요하게 됩니다.
    - 의존성 배열 자체가 없다면 **useEffect는 렌더링이 일어날 때마다 계속 실행됩니다**.
    - **의존성 배열이 있고, 내부에 요소가 없다면 useEffect는 최초로 사이트를 띄운 이후부터는 실행되지 않습니다.**
    - **의존성 배열이 있고, 내부에 요소가 있다면 해당 요소의 데이터가 변경되거나 갱신될 때마다 useEffect의 내용이 실행**되도록 되어있습니다.
- useEffect에서는 갱신 시 실행되는 업데이트 내용 외에도, **useEffect를 적용한 컴포넌트가 제거될 시 리소스를 정리해야 합니다.**
이 과정을 React에서는 Clean-up이라고 부르며, **업데이트 내용 뒤에 return을 붙여 cleanup을 적용하도록 합니다.**

### var, let, const의 차이에 대해 알려주세요.

- const로 선언한 변수명은 절대적이므로 변경되지 않으며 초기화를 통해 변수에 할당한 값도 절대적으로 변경되지 않습니다.
- let은 const와 같은 점으로서 선언한 변수명 자체는 절대적이므로 재선언이 불가능하나 변수 속 값은 재할당할 수 있다는 차이가 있습니다.
- var의 경우, 재선언에다 재할당도 가능한데 거기에 중복 선언까지 가능하다는 이슈가 있습니다.
- var의 이런 자유로운 점은 변수를 이용할 시 예기치 못한 문제를 발생할 수 있으므로 되도록 const와 let을 활용해 변수를 관리하는 것이 좋습니다.

### Async/Await와 Promise의 차이

- promise는 자바스크립트에서 비동기 처리에 사용되는 객체입니다.
- **내용은 실행 되었지만 결과를 아직 반환하지 않은 객체**라고 이해해도 좋습니다.
- 값이 참이면 resolve 를 호출하고, 아닐시에는 reject 를 호출한다.
- resolve 한 반환 값에 대해서는 then() 을 통해 결과 값을 반환 받을 수 있고 reject 의 반환 값에 대해서는 catch() 를 통해 반환 받는다.
- 함수에 `async` 키워드를 적고, 비동기 대상에 `await`를 추가해주면 된다.
- 비동기 대상 함수에 `await`를 추가하면, *'이 함수의 처리를 기다려!'* 라는 의미가 되기에
- `await` 함수 아래에 해당 함수의 응답값을 사용하는 구문을 추가해주면 된다.
- `async await`를 사용하게 되면 하나의 `catch`만 해주면된다!
- 해당 `catch`문에서는 `try` 내부에서 발생하는 모든 에러를 접근할 수 있다.

### 데이터 10,000개를 가지고 무한 스크롤 구현시에 가장 중요하게 고려해야 할점은?

- 무한스크롤은 트위터나 페이스북 같은 단발성 메시지가 주가 되는 SNS에서는, 최근 글에만 신경쓰게 할 수 있지만, 그렇지 않은 사이트들은 가령 열 페이지 뒤쪽의 게시물을 보기 위해서 페이지 로딩을 열 번을 해야 되는 번거로움이 고려해야 할 점입니다.
- 즉 과거 데이터를 보고 싶은 사람들이 많은 사이트라면, 무한스크롤 구현을 하기에 적합하지 않다는 것을 고려해야 합니다.

### CloudFront를 사용해본적이 있나요? 사용해봤다면, CloudFront로 배포하는 이유를 설명해주세요

- S3 버킷은 선택한 리전 내에만 생성되기 때문에 해당 리전에서 멀어질수록 접속 속도가 느려지게 되는데요.
- 또한, 동시 접속수가 많아질수록 느려지기도 하고요. 그렇기 때문에 이 문제를 해결하기 위해 CloudFront 라는 서비스를 S3와 함께 사용하게 됩니다.
- CloudFront란 전 세계의 정적/동적 웹 콘텐츠, 비디오 스트림 및 API를 안전하게 대규모로 전송할 수 있는 콘텐츠 전송 네트워크 서비스라고 할 수 있어요.
- CloudFront는 전 세계에 분포된 엣지 로케이션이라고 하는 데이터 센터의 엣지 서버를 사용해 콘텐츠를 캐싱하고, 사용자가 위치한 곳에서 가장 가까운 엣지 로케이션에서 콘텐츠를 제공받을 수 있도록 해주는 역할을 합니다(CDN).
- 또 호스팅을 HTTPS로 하게 할 수도 있는 점에서 보안을 향상 시킬수 있어서 CloudFront로 배포를 합니다.

### useEffect와 useLayoutEffect 차이에 대해 설명해주세요

- useEffect 는 컴포넌트들이 render 와 paint 된 후 실행됩니다. **비동기적(asynchronous)**으로 실행됩니다.
- paint 된 후 실행되기 때문에, useEffect 내부에 dom 에 영향을 주는 코드가 있을 경우 사용자 입장에서는 **화면의 깜빡임을 보게됩니다**
- useLayoutEffect 는 컴포넌트들이 render 된 후 실행되며, 그 이후에 paint 가 됩니다. 이 작업은 **동기적(synchronous)**으로 실행됩니다.
- paint 가 되기전에 실행되기 때문에 dom 을 조작하는 코드가 존재하더라도 사용자는 **깜빡임을 경험하지 않습니다**
- 화면이 깜빡거리는 상황일 때, 예를들어 state가 존재하며, 해당 state가 조건에 따라 첫 painting 시 다르게 렌더링 되어야 할 때는 useLayoutEffect사용

### Closure란?

- **“자신이 선언될 당시의 환경을 기억하는 함수”**
- 흔히말해 함수 내에서 함수를 선언하고 사용하면 클로저라고 한다.
- 여기서 바깥쪽 함수는 **외부함수**, 그 안에서 선언한 함수는 **내부함수**
라고 부른다.

```jsx
function hello(name) {
  let _name = name;
  console.log('Hello, '+_name);
}

hello('백산'); // [출력] : Hello, 백산
hello('신우'); // [출력] : Hello, 신우
```

```jsx
function hello(name) {
  let _name = name;
  return function() {
    console.log('Hello, '+_name);
  }
}

let hello1 = hello('백산');
let hello2 = hello('신우');
hello1(); // [출력] : Hello, 백산
hello2(); // [출력] : Hello, 신우
```

- 일반함수에서는 hello('백산')를 정의한 시점에서 _name은 '백산'이라는 string으로 결정된다.
- 출력이 끝난 후에는 해당 함수는 소멸(해당 함수의 전역변수가 초기화됨)되어 다시 같은 함수를 사용하기 위해서는 또다시 백산이라는 string을 받는 함수를 선언해야만 한다.
- 그에 비해 내부함수의 경우 hello('백산')으로 정의된 함수가 소멸하지 않고 내부의 클로저가 외부함수의 전역변수 값을 기억하고 있다.
- 따라서 hello1()을 사용하기만 해도 **클로저가 외부함수의 전역변수값을 가져와 출력**한다.
- 이점이 일반함수와 내부함수가 다른점이다.
- 일반함수는 **선언할때마다 내부의 전역변수가 초기화**되지만 내부함수는 **선언했을때의 환경을 기억**하고 있다가 여러번 실행할 수 있다.
- 클로저는 일반함수와 달리 함수 **내부에 선언되는 함수로 함수가 실행될때 외부변수에 접근하기 위한 객체**이다.

### Javascript 호이스팅에 대해 설명해주세요.

- 함수 안에 있는 선언들을 모두 끌어올려서 해당 함수 유효 범위의 최상단에 선언하는 것을 말한다.
    - 자바스크립트 Parser가 함수 실행 전 해당 함수를 한 번 훑는다.
    - 함수 안에 존재하는 변수/함수선언에 대한 정보를 기억하고 있다가 실행시킨다.
    - 유효 범위: 함수 블록 {} 안에서 유효
- var 변수 선언과 함수선언문에서만 호이스팅이 일어난다.
    - var 변수/함수의 선언만 위로 끌어 올려지며, 할당은 끌어 올려지지 않는다.
    - let/const 변수 선언과 함수표현식에서는 호이스팅이 발생하지 않는다.

### 프로세스 생성 과정에 대해 설명해보세요

- 프로세스는 간단히 말하자면 실행 중인 프로그램을 의미합니다. 아마 여러분들은 컴퓨터를 하면서 아주 빈번하게 듣는 용어이기도 합니다.
- 컴퓨터에서 말하는 실행 중인 프로그램이라는 건 저장공간에 있는 실행 파일이 메모리를 할당받아 명령어를 수행한다는 것을 의미합니다.
- 프로세스 제어 블록(PCB)가 생성되며 OS가 실행한 프로그램의 코드를 읽어들여 프로세스에 할당된 메모리의 Text segment에 저장한다.
- 초기화된 전역 변수 및 static 변수를 data segment에 할당.
- HEAP과 Stack은 초기 메모리 주소만 초기화됨.
- PCB에 여러 정보가 기록되면 Ready Queue에서 CPU를 할당받기까지 대기한다.

### HTTPS란

- HTTP란 HyperText Transfer Protocol의 약자로써, 풀어서 설명하면 **하이퍼텍스트(HyperText)를 전송(Transfer)하기 위해 사용되는 통신 규약(Protocol)**
이다.
- 즉, 인터넷에서 HTML과 같은 문서를 사용자 컴퓨터에 설치된 웹 브라우저가 웹 서버에 요청할 때의 규칙이라고 할 수 있다.
- HTTPS는 HTTP에서 데이터를 주고 받는 과정에 ‘보안’ 요소가 추가되었다는 것이 가장 큰 차이점이다.
- HTTPS를 사용하면 **서버와 클라이언트 사이의 모든 통신 내용이 암호화**된다.

### TCP란 무엇인가

- TCP는 말 그대로 **전송 제어를 위한 작업을 해주는 역할**
- TCP는 두가지 역할을 한다.
    - **받을 대상 노드(호스트)가 서비스 가능(연결 가능) 상태인지 확인 및 연결을 수립하는 역할**
    - **전송을 제어해주는 정보를 패킷에 추가해주는 역할**
- 받을 대상 노드(호스트)가 서비스 가능 상태인지 확인하기 위해서는 해당 노드가 활성 상태인지 확인하기 위해 통신을 해야 한다.
- TCP에서는 3 Way Handshake라는 방식으로 해당 노드와 통신을 수행하게 된다.
- **SYN 단계**
    - 어플리케이션이 서버에 통신을 위한 연결을 요청하는 단계
- **SYN-ACK 단계**
    - 서버가 어플리케이션에 자신이 활성 상태임을 알리고 어플리케이션에서도 포트를 열어 연결을 활성화하라는 요청 메세지를 전송
- **ACK 단계**
    - 어플리케이션이 서버의 요청 메세지를 수락하여 연결이 수립
- 전송을 제어해주는 규약(Protocol)에 대한 정보를 패킷에 추가한다. 대표적으로 Port 정보, 순서 정보가 있다.
- **Port 정보는 패킷이 어떤 프로세스에 전달되어야 할지에 대한 정보**
로, 프로세스간 통신을 위해 사용되는 정보이다.
- **전송 제어 정보 중 하나인 순서 정보는 전달해야 하는 패킷이 여러개로 나뉘어져 있을 경우 각 패킷이 어떤 순서로 처리되어야 하는지에 대한 정보**이다.

### TCP와 UDP의 차이점은?

- 연결형 서비스를 지원하는 전송 계층 프로토콜로써, 인터넷 환경에서 기본으로 사용합니다.
- 호스트간 신뢰성 있는 데이터 전달과 흐름제어를 합니다. 즉, 인터넷상에서 데이터를 메시지의 형태로 보내기 위해 IP와 함께 사용하는 프로토콜입니다.
- 일반적으로 TCP와 IP를 함께 사용하는데, IP가 데이터의 배달을 처리한다면 TCP는 패킷을 추적 및 관리하게 됩니다.
- 데이터의 전송 순서를 보장한다.
- 비연결형 서비스를 지원하는 전송계층 프로토콜로써, 인터넷상에서 서로 정보를 주고받을 때 정보를 보낸다는 신호나 받는다는 신호 절차를 거치지 않고, 보내는 쪽에서 일방적으로 데이터를 전달하는 통신 프로토콜입니다.
- 데이터를 데이터그램 단위로 처리하는 프로토콜입니다.
- TCP는 연속성보다 신뢰성있는 전송이 중요할 때에 사용하는 프로토콜이며, UDP는 TCP보다 속도가 빠르며 네트워크 부하가 적다는 장점이 있지만, 신뢰성있는 데이터 전송을 보장하지는 않습니다.
- 그렇기 때문에 신뢰성보다는 연속성이 중요한 서비스의 예를 들면 실시간 서비스(streaming)에 자주 사용됩니다.
