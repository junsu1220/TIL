### 상태관리를 왜 할까요? 그리고 평소 state 관리는 어떻게 하시나요?

- 단순 정보전달의 정적인 웹 사이트 부터 상호작용으로 구성되는 동적 웹 페이지로 변화하는 과정 속에서 데이터 관리의 필요성이 나타났습니다.
- 한가지 예로 DB로부터 받아온 데이터가 공통적으로 재사용 되는 일이 늘어남에 따라 API 호출 횟수에 직접적으로 연관되는 DB의 의존도를 줄일 필요가 있었습니다.
- 데이터가 필요할 때 마다 서버를 호출 하는 것은 비효율적 이므로 DB로부터 분리된 상태 저장소의 필요성이 나타나게 되었습니다.
- 정확하고 효율적인 상태 관리는 DB와의 접촉 횟수를 줄여주며 안정적이고 지속적인 서비스 제공을 가능하게 합니다.
- 현재 상태관리 라이브러리 중 하나인 Redux-toolkit를 사용하여 전역적으로 상태를 관리해 단방향 데이터 흐름을 지키기위해 노력하고 있습니다.
- 상태관리를 하는 이유는 유저와의 상호작용으로부터 데이터를 갱신시켜줘야 하기 때문으로 알고 있습니다.
- 저는 상태관리를 어떠한 동작에 의해 UI,UX 내의 변화가 필요할 때
    - 그 데이터가 단독으로 관리 가능하다면 useState를 이용해서 지역적으로 관리하고
    - 비동기통신의 결과로 로딩여부가 필요하거나 다른 컴포넌트들에서 그 데이터를 사용한다면 redux를 사용해 전역적으로 관리합니다.

### Redux가 무엇인가요, 왜 Redux를 사용하시나요?

- 리덕스란 전역 상태 저장소입니다.
- 저장된 데이터를 App 이 가져다 쓰고, 자식들도 가져다 쓰는 것입니다.
- 부모의 state를 간섭하는 것이 아니라서 유용하게 쓰입니다.
- 아래로 전달해주기 위해 쓸데없는 데이터를 가지고 있게 되는 props driling을 해결해주기 위해 리덕스를 사용한다.

### Redux 말고 다른 전역 상태관리 아는 것 하나와 차이점을 말해주세요

- Redux는 store라는 관리 공간 속에서 여러 reducer들을 이용해 **각각의 reducer에서 쓰이는 state를 관리하는 방식으로 운영**된다.
- 반면, Recoil은 atom이라는 즉, **원자라고 불리는 상태 저장소를 통해 state를 관리**한다.
- 이 atom은 **store와 같은 하나의 전역 관리 객체 속에서 관리되는 방식이 아닌 말그대로 각각의 atom에 관리되고 있다.**
- Redux의 핵심은 reducer를 통해서 state를 관리하는 것인데 이때 **state를 저장, 변경, 삭제 등을 하기 위해 dispatch라는 메소드를 이용해 관리**한다.
- dispatch를 이용할 때는 두 가지 값이 필요한데, 하나는 **우리가 현재 가지고 있는 state**이며 다른 하나는 이 state를 이용해서 **어떠한 행위와 갱신할 값의 정보를 들고 있는 action이 필요**하다.
- 반면 **Recoil은** dispatch의 방식이 아닌 우리가 React에서 익숙하게 쓰고 있는 **useState의 형식을 그대로 따라간다.**
- useRecoilState를 이용해서 atom에 있는 값들을 변화하여 상태관리를 할 수 있는데 이 Recoil에는 useState에서 쓰이는 기존 값을 불러오는 읽기 전용, 기존 값을 덮어씌우는 쓰기 전용으로도 **함수를 따로 분리해 쓸 수 있도록 했다는 점이 특징**이다.

### 버츄얼 돔과 리얼 돔의 차이를 설명해주세요

- DOM은 웹 브라우저가 html 파일, 문서를 접근하기 위한 혹은 인식하기 위한 모델, 방식, 인터페이스입니다.
- JavaScript는 이러한 웹 페이지들의 태그를 인식해 추가, 수정, 삭제, 변화 등 다양한 작업을 처리할 수 있습니다.
- 기존의 DOM 요소에서 데이터를 저장하거나 변경하는 사항이 생기면 DOM을 전부 갱신하여 새로 불러와줘야 한다는 제약이 있습니다.
- React에서는 이 과정이 반복되는 것이 비효율적이라고 생각하였고, DOM을 본 뜬 가상 DOM을 이용하면 데이터의 변화가 생길 때 가상 DOM과 DOM을 비교해 달라진 부분만을 변경하여 갱신해줌으로서 불필요하게 DOM을 전부 불러오는 문제를 방지할 수 있었습니다.

### useRef에 대해 설명해보세요
- **useRef**란 어떠한 **특정 DOM**을 선택할 수 있게 해줍니다.
- 코딩을 하다보면 DOM을 직접 선택해서 포커스를 주거나 특정 엘리먼트의 크기나 색상을 변경하는 경우가 있는데 그때 사용하는 것입니다.
- 특정 DOM을 선택하는 용도 이외에도 **Component 안에서 조회 및 수정이 가능한 변수를 관리하는 용도**로도 사용된다.
- 하지만 **useRef** 이용해서 변수를 업데이트 하게 되면 해당 Component가 리렌더링 되지 않기 때문에 용도에 맞게 사용해야 합니다.

### useEffect의 실행 순서에 대해 설명해주세요

- 우선 **최초로 사이트를 띄울 시, useEffect의 내용이 반드시 실행**되도록 되어있습니다.
- 이 과정 속에서 dependency array, **의존성 배열**의 존재가 중요하게 됩니다.
    - 의존성 배열 자체가 없다면 **useEffect는 렌더링이 일어날 때마다 계속 실행됩니다**.
    - **의존성 배열이 있고, 내부에 요소가 없다면 useEffect는 최초로 사이트를 띄운 이후부터는 실행되지 않습니다.**
    - **의존성 배열이 있고, 내부에 요소가 있다면 해당 요소의 데이터가 변경되거나 갱신될 때마다 useEffect의 내용이 실행**되도록 되어있습니다.
- useEffect에서는 갱신 시 실행되는 업데이트 내용 외에도, **useEffect를 적용한 컴포넌트가 제거될 시 리소스를 정리해야 합니다.**
이 과정을 React에서는 Clean-up이라고 부르며, **업데이트 내용 뒤에 return을 붙여 cleanup을 적용하도록 합니다.**

### useEffect의 실행 순서에 대해 설명해주세요

- 우선 **최초로 사이트를 띄울 시, useEffect의 내용이 반드시 실행**되도록 되어있습니다.
- 이 과정 속에서 dependency array, **의존성 배열**의 존재가 중요하게 됩니다.
    - 의존성 배열 자체가 없다면 **useEffect는 렌더링이 일어날 때마다 계속 실행됩니다**.
    - **의존성 배열이 있고, 내부에 요소가 없다면 useEffect는 최초로 사이트를 띄운 이후부터는 실행되지 않습니다.**
    - **의존성 배열이 있고, 내부에 요소가 있다면 해당 요소의 데이터가 변경되거나 갱신될 때마다 useEffect의 내용이 실행**되도록 되어있습니다.
- useEffect에서는 갱신 시 실행되는 업데이트 내용 외에도, **useEffect를 적용한 컴포넌트가 제거될 시 리소스를 정리해야 합니다.**
이 과정을 React에서는 Clean-up이라고 부르며, **업데이트 내용 뒤에 return을 붙여 cleanup을 적용하도록 합니다.**
