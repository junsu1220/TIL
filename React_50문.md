### 상태관리를 왜 할까요? 그리고 평소 state 관리는 어떻게 하시나요?

- 단순 정보전달의 정적인 웹 사이트 부터 상호작용으로 구성되는 동적 웹 페이지로 변화하는 과정 속에서 데이터 관리의 필요성이 나타났습니다.
- 한가지 예로 DB로부터 받아온 데이터가 공통적으로 재사용 되는 일이 늘어남에 따라 API 호출 횟수에 직접적으로 연관되는 DB의 의존도를 줄일 필요가 있었습니다.
- 데이터가 필요할 때 마다 서버를 호출 하는 것은 비효율적 이므로 DB로부터 분리된 상태 저장소의 필요성이 나타나게 되었습니다.
- 정확하고 효율적인 상태 관리는 DB와의 접촉 횟수를 줄여주며 안정적이고 지속적인 서비스 제공을 가능하게 합니다.
- 현재 상태관리 라이브러리 중 하나인 Redux-toolkit를 사용하여 전역적으로 상태를 관리해 단방향 데이터 흐름을 지키기위해 노력하고 있습니다.
- 상태관리를 하는 이유는 유저와의 상호작용으로부터 데이터를 갱신시켜줘야 하기 때문으로 알고 있습니다.
- 저는 상태관리를 어떠한 동작에 의해 UI,UX 내의 변화가 필요할 때
    - 그 데이터가 단독으로 관리 가능하다면 useState를 이용해서 지역적으로 관리하고
    - 비동기통신의 결과로 로딩여부가 필요하거나 다른 컴포넌트들에서 그 데이터를 사용한다면 redux를 사용해 전역적으로 관리합니다.

### Redux가 무엇인가요, 왜 Redux를 사용하시나요?

- 리덕스란 전역 상태 저장소입니다.
- 저장된 데이터를 App 이 가져다 쓰고, 자식들도 가져다 쓰는 것입니다.
- 부모의 state를 간섭하는 것이 아니라서 유용하게 쓰입니다.
- 아래로 전달해주기 위해 쓸데없는 데이터를 가지고 있게 되는 props driling을 해결해주기 위해 리덕스를 사용한다.

### Redux 말고 다른 전역 상태관리 아는 것 하나와 차이점을 말해주세요

- Redux는 store라는 관리 공간 속에서 여러 reducer들을 이용해 **각각의 reducer에서 쓰이는 state를 관리하는 방식으로 운영**된다.
- 반면, Recoil은 atom이라는 즉, **원자라고 불리는 상태 저장소를 통해 state를 관리**한다.
- 이 atom은 **store와 같은 하나의 전역 관리 객체 속에서 관리되는 방식이 아닌 말그대로 각각의 atom에 관리되고 있다.**
- Redux의 핵심은 reducer를 통해서 state를 관리하는 것인데 이때 **state를 저장, 변경, 삭제 등을 하기 위해 dispatch라는 메소드를 이용해 관리**한다.
- dispatch를 이용할 때는 두 가지 값이 필요한데, 하나는 **우리가 현재 가지고 있는 state**이며 다른 하나는 이 state를 이용해서 **어떠한 행위와 갱신할 값의 정보를 들고 있는 action이 필요**하다.
- 반면 **Recoil은** dispatch의 방식이 아닌 우리가 React에서 익숙하게 쓰고 있는 **useState의 형식을 그대로 따라간다.**
- useRecoilState를 이용해서 atom에 있는 값들을 변화하여 상태관리를 할 수 있는데 이 Recoil에는 useState에서 쓰이는 기존 값을 불러오는 읽기 전용, 기존 값을 덮어씌우는 쓰기 전용으로도 **함수를 따로 분리해 쓸 수 있도록 했다는 점이 특징**이다.

### 버츄얼 돔과 리얼 돔의 차이를 설명해주세요

- DOM은 웹 브라우저가 html 파일, 문서를 접근하기 위한 혹은 인식하기 위한 모델, 방식, 인터페이스입니다.
- JavaScript는 이러한 웹 페이지들의 태그를 인식해 추가, 수정, 삭제, 변화 등 다양한 작업을 처리할 수 있습니다.
- 기존의 DOM 요소에서 데이터를 저장하거나 변경하는 사항이 생기면 DOM을 전부 갱신하여 새로 불러와줘야 한다는 제약이 있습니다.
- React에서는 이 과정이 반복되는 것이 비효율적이라고 생각하였고, DOM을 본 뜬 가상 DOM을 이용하면 데이터의 변화가 생길 때 가상 DOM과 DOM을 비교해 달라진 부분만을 변경하여 갱신해줌으로서 불필요하게 DOM을 전부 불러오는 문제를 방지할 수 있었습니다.

### useRef에 대해 설명해보세요
- **useRef**란 어떠한 **특정 DOM**을 선택할 수 있게 해줍니다.
- 코딩을 하다보면 DOM을 직접 선택해서 포커스를 주거나 특정 엘리먼트의 크기나 색상을 변경하는 경우가 있는데 그때 사용하는 것입니다.
- 특정 DOM을 선택하는 용도 이외에도 **Component 안에서 조회 및 수정이 가능한 변수를 관리하는 용도**로도 사용된다.
- 하지만 **useRef** 이용해서 변수를 업데이트 하게 되면 해당 Component가 리렌더링 되지 않기 때문에 용도에 맞게 사용해야 합니다.

### useEffect의 실행 순서에 대해 설명해주세요

- 우선 **최초로 사이트를 띄울 시, useEffect의 내용이 반드시 실행**되도록 되어있습니다.
- 이 과정 속에서 dependency array, **의존성 배열**의 존재가 중요하게 됩니다.
    - 의존성 배열 자체가 없다면 **useEffect는 렌더링이 일어날 때마다 계속 실행됩니다**.
    - **의존성 배열이 있고, 내부에 요소가 없다면 useEffect는 최초로 사이트를 띄운 이후부터는 실행되지 않습니다.**
    - **의존성 배열이 있고, 내부에 요소가 있다면 해당 요소의 데이터가 변경되거나 갱신될 때마다 useEffect의 내용이 실행**되도록 되어있습니다.
- useEffect에서는 갱신 시 실행되는 업데이트 내용 외에도, **useEffect를 적용한 컴포넌트가 제거될 시 리소스를 정리해야 합니다.**
이 과정을 React에서는 Clean-up이라고 부르며, **업데이트 내용 뒤에 return을 붙여 cleanup을 적용하도록 합니다.**

### useEffect의 실행 순서에 대해 설명해주세요

- 우선 **최초로 사이트를 띄울 시, useEffect의 내용이 반드시 실행**되도록 되어있습니다.
- 이 과정 속에서 dependency array, **의존성 배열**의 존재가 중요하게 됩니다.
    - 의존성 배열 자체가 없다면 **useEffect는 렌더링이 일어날 때마다 계속 실행됩니다**.
    - **의존성 배열이 있고, 내부에 요소가 없다면 useEffect는 최초로 사이트를 띄운 이후부터는 실행되지 않습니다.**
    - **의존성 배열이 있고, 내부에 요소가 있다면 해당 요소의 데이터가 변경되거나 갱신될 때마다 useEffect의 내용이 실행**되도록 되어있습니다.
- useEffect에서는 갱신 시 실행되는 업데이트 내용 외에도, **useEffect를 적용한 컴포넌트가 제거될 시 리소스를 정리해야 합니다.**
이 과정을 React에서는 Clean-up이라고 부르며, **업데이트 내용 뒤에 return을 붙여 cleanup을 적용하도록 합니다.**

### var, let, const의 차이에 대해 알려주세요.

- const로 선언한 변수명은 절대적이므로 변경되지 않으며 초기화를 통해 변수에 할당한 값도 절대적으로 변경되지 않습니다.
- let은 const와 같은 점으로서 선언한 변수명 자체는 절대적이므로 재선언이 불가능하나 변수 속 값은 재할당할 수 있다는 차이가 있습니다.
- var의 경우, 재선언에다 재할당도 가능한데 거기에 중복 선언까지 가능하다는 이슈가 있습니다.
- var의 이런 자유로운 점은 변수를 이용할 시 예기치 못한 문제를 발생할 수 있으므로 되도록 const와 let을 활용해 변수를 관리하는 것이 좋습니다.

### Async/Await와 Promise의 차이

- promise는 자바스크립트에서 비동기 처리에 사용되는 객체입니다.
- **내용은 실행 되었지만 결과를 아직 반환하지 않은 객체**라고 이해해도 좋습니다.
- 값이 참이면 resolve 를 호출하고, 아닐시에는 reject 를 호출한다.
- resolve 한 반환 값에 대해서는 then() 을 통해 결과 값을 반환 받을 수 있고 reject 의 반환 값에 대해서는 catch() 를 통해 반환 받는다.
- 함수에 `async` 키워드를 적고, 비동기 대상에 `await`를 추가해주면 된다.
- 비동기 대상 함수에 `await`를 추가하면, *'이 함수의 처리를 기다려!'* 라는 의미가 되기에
- `await` 함수 아래에 해당 함수의 응답값을 사용하는 구문을 추가해주면 된다.
- `async await`를 사용하게 되면 하나의 `catch`만 해주면된다!
- 해당 `catch`문에서는 `try` 내부에서 발생하는 모든 에러를 접근할 수 있다.

### 데이터 10,000개를 가지고 무한 스크롤 구현시에 가장 중요하게 고려해야 할점은?

- 무한스크롤은 트위터나 페이스북 같은 단발성 메시지가 주가 되는 SNS에서는, 최근 글에만 신경쓰게 할 수 있지만, 그렇지 않은 사이트들은 가령 열 페이지 뒤쪽의 게시물을 보기 위해서 페이지 로딩을 열 번을 해야 되는 번거로움이 고려해야 할 점입니다.
- 즉 과거 데이터를 보고 싶은 사람들이 많은 사이트라면, 무한스크롤 구현을 하기에 적합하지 않다는 것을 고려해야 합니다.

### CloudFront를 사용해본적이 있나요? 사용해봤다면, CloudFront로 배포하는 이유를 설명해주세요

- S3 버킷은 선택한 리전 내에만 생성되기 때문에 해당 리전에서 멀어질수록 접속 속도가 느려지게 되는데요.
- 또한, 동시 접속수가 많아질수록 느려지기도 하고요. 그렇기 때문에 이 문제를 해결하기 위해 CloudFront 라는 서비스를 S3와 함께 사용하게 됩니다.
- CloudFront란 전 세계의 정적/동적 웹 콘텐츠, 비디오 스트림 및 API를 안전하게 대규모로 전송할 수 있는 콘텐츠 전송 네트워크 서비스라고 할 수 있어요.
- CloudFront는 전 세계에 분포된 엣지 로케이션이라고 하는 데이터 센터의 엣지 서버를 사용해 콘텐츠를 캐싱하고, 사용자가 위치한 곳에서 가장 가까운 엣지 로케이션에서 콘텐츠를 제공받을 수 있도록 해주는 역할을 합니다(CDN).
- 또 호스팅을 HTTPS로 하게 할 수도 있는 점에서 보안을 향상 시킬수 있어서 CloudFront로 배포를 합니다.

### useEffect와 useLayoutEffect 차이에 대해 설명해주세요

- useEffect 는 컴포넌트들이 render 와 paint 된 후 실행됩니다. **비동기적(asynchronous)**으로 실행됩니다.
- paint 된 후 실행되기 때문에, useEffect 내부에 dom 에 영향을 주는 코드가 있을 경우 사용자 입장에서는 **화면의 깜빡임을 보게됩니다**
- useLayoutEffect 는 컴포넌트들이 render 된 후 실행되며, 그 이후에 paint 가 됩니다. 이 작업은 **동기적(synchronous)**으로 실행됩니다.
- paint 가 되기전에 실행되기 때문에 dom 을 조작하는 코드가 존재하더라도 사용자는 **깜빡임을 경험하지 않습니다**
- 화면이 깜빡거리는 상황일 때, 예를들어 state가 존재하며, 해당 state가 조건에 따라 첫 painting 시 다르게 렌더링 되어야 할 때는 useLayoutEffect사용

### Closure란?

- **“자신이 선언될 당시의 환경을 기억하는 함수”**
- 흔히말해 함수 내에서 함수를 선언하고 사용하면 클로저라고 한다.
- 여기서 바깥쪽 함수는 **외부함수**, 그 안에서 선언한 함수는 **내부함수**
라고 부른다.

```jsx
function hello(name) {
  let _name = name;
  console.log('Hello, '+_name);
}

hello('백산'); // [출력] : Hello, 백산
hello('신우'); // [출력] : Hello, 신우
```

```jsx
function hello(name) {
  let _name = name;
  return function() {
    console.log('Hello, '+_name);
  }
}

let hello1 = hello('백산');
let hello2 = hello('신우');
hello1(); // [출력] : Hello, 백산
hello2(); // [출력] : Hello, 신우
```

- 일반함수에서는 hello('백산')를 정의한 시점에서 _name은 '백산'이라는 string으로 결정된다.
- 출력이 끝난 후에는 해당 함수는 소멸(해당 함수의 전역변수가 초기화됨)되어 다시 같은 함수를 사용하기 위해서는 또다시 백산이라는 string을 받는 함수를 선언해야만 한다.
- 그에 비해 내부함수의 경우 hello('백산')으로 정의된 함수가 소멸하지 않고 내부의 클로저가 외부함수의 전역변수 값을 기억하고 있다.
- 따라서 hello1()을 사용하기만 해도 **클로저가 외부함수의 전역변수값을 가져와 출력**한다.
- 이점이 일반함수와 내부함수가 다른점이다.
- 일반함수는 **선언할때마다 내부의 전역변수가 초기화**되지만 내부함수는 **선언했을때의 환경을 기억**하고 있다가 여러번 실행할 수 있다.
- 클로저는 일반함수와 달리 함수 **내부에 선언되는 함수로 함수가 실행될때 외부변수에 접근하기 위한 객체**이다.
